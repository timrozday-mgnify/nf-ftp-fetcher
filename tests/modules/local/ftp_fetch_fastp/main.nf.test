nextflow_process {

    name "Test Process FTP_FETCH_FASTP"
    script "modules/local/ftp_fetch_fastp/main.nf"
    process "FTP_FETCH_FASTP"
    config "tests/modules/local/ftp_fetch_fastp/nextflow.config"

    // =========================================================================
    // test_se: Single-end — successful download and fastp
    // =========================================================================

    test("test_se: downloads and processes single-end reads successfully") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se', single_end: true],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_1.fastq.gz',
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 3     // max_retries
                input[5] = 10    // wait_retry
                input[6] = 60    // timeout
                input[7] = true  // resume
                input[8] = false // soft_fail
                """
            }
        }

        then {
            assert process.success

            // Verify all expected outputs are emitted
            assert process.out.reads.size() == 1
            assert process.out.json.size() == 1
            assert process.out.html.size() == 1
            assert process.out.log.size() == 1
            assert process.out.download_log.size() == 1
            assert process.out.status.size() == 1

            // Status should report success
            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "true"

            // Download log should show a clean first-attempt success
            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/3 ===")
            assert log_text.contains("Download succeeded, running fastp...")
            assert log_text.contains("fastp succeeded on attempt 1")
            // No failures should be logged
            assert !log_text.contains("Download failed")
            assert !log_text.contains("fastp failed")
            assert !log_text.contains("Attempt 2/3")
        }
    }

    // =========================================================================
    // test_se_wrong_path: wget retry — 2 retries, soft fail
    // =========================================================================

    test("test_se_wrong_path: retries wget download 2 times then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se_wrong_path', single_end: true],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412__1.fastq.gz',
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 2     // max_retries
                input[5] = 1     // wait_retry (short for testing)
                input[6] = 5     // timeout (short for testing)
                input[7] = false // resume
                input[8] = true  // soft_fail
                """
            }
        }

        then {
            // Process should succeed due to soft_fail=true
            assert process.success

            // Status should report failure
            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            // Download log should show exactly 2 attempts, both failing
            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/2 ===")
            assert log_text.contains("=== Attempt 2/2 ===")
            assert log_text.contains("Download failed")
            assert log_text.contains("All 2 attempts failed")
            assert log_text.contains("Soft fail mode: creating empty output files")

            // Sleep between attempts
            assert log_text.contains("Sleeping 1s before next attempt...")

            // fastp should never have been attempted
            assert !log_text.contains("running fastp")
        }
    }

    // =========================================================================
    // test_se_wrong_path: wget retry — 3 retries, soft fail
    // =========================================================================

    test("test_se_wrong_path: retries wget download 3 times then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se_wrong_path', single_end: true],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412__1.fastq.gz',
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 3     // max_retries
                input[5] = 1     // wait_retry
                input[6] = 5     // timeout
                input[7] = false // resume
                input[8] = true  // soft_fail
                """
            }
        }

        then {
            assert process.success

            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            // All 3 attempts logged
            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/3 ===")
            assert log_text.contains("=== Attempt 2/3 ===")
            assert log_text.contains("=== Attempt 3/3 ===")
            assert log_text.contains("Download failed")
            assert log_text.contains("All 3 attempts failed")
            assert log_text.contains("Soft fail mode: creating empty output files")

            // Should NOT have a fourth attempt
            assert !log_text.contains("Attempt 4/")
        }
    }

    // =========================================================================
    // test_se_wrong_path: wget retry — 1 retry, short timeout, soft fail
    // =========================================================================

    test("test_se_wrong_path: single attempt with short timeout then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se_wrong_path', single_end: true],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412__1.fastq.gz',
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 1     // max_retries (single attempt)
                input[5] = 1     // wait_retry
                input[6] = 3     // timeout (very short)
                input[7] = false // resume
                input[8] = true  // soft_fail
                """
            }
        }

        then {
            assert process.success

            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/1 ===")
            assert log_text.contains("Download failed")
            assert log_text.contains("All 1 attempts failed")

            // Only one attempt — no sleeping, no second attempt
            assert !log_text.contains("Sleeping")
            assert !log_text.contains("Attempt 2/")
        }
    }

    // =========================================================================
    // test_se_wrong_path: hard failure — soft_fail disabled
    // =========================================================================

    test("test_se_wrong_path: fails when soft_fail is disabled") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se_wrong_path', single_end: true],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412__1.fastq.gz',
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 1     // max_retries
                input[5] = 1     // wait_retry
                input[6] = 5     // timeout
                input[7] = false // resume
                input[8] = false // soft_fail disabled
                """
            }
        }

        then {
            assert process.failed
        }
    }

    // =========================================================================
    // test_pe: Paired-end — successful download and fastp
    // =========================================================================

    test("test_pe: downloads and processes paired-end reads successfully") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_pe', single_end: false],
                    ['ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_1.fastq.gz',
                     'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_2.fastq.gz'],
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 3     // max_retries
                input[5] = 10    // wait_retry
                input[6] = 60    // timeout
                input[7] = true  // resume
                input[8] = false // soft_fail
                """
            }
        }

        then {
            assert process.success

            // Verify outputs
            assert process.out.reads.size() == 1
            assert process.out.json.size() == 1
            assert process.out.html.size() == 1
            assert process.out.log.size() == 1
            assert process.out.download_log.size() == 1
            assert process.out.status.size() == 1

            // Status should report success
            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "true"

            // Log should show both R1 and R2 downloads then fastp success
            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/3 ===")
            assert log_text.contains("Downloading")
            assert log_text.contains("ERR10889412_1.fastq.gz")
            assert log_text.contains("ERR10889412_2.fastq.gz")
            assert log_text.contains("Download succeeded, running fastp...")
            assert log_text.contains("fastp succeeded on attempt 1")
            assert !log_text.contains("Download failed")
            assert !log_text.contains("fastp failed")
        }
    }

    // =========================================================================
    // test_pe_mismatch: fastp retry — 2 retries, soft fail
    // =========================================================================

    test("test_pe_mismatch: retries on fastp failure 2 times then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_pe_mismatch', single_end: false],
                    ['ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_1.fastq.gz',
                     'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/007/ERR10889407/ERR10889407_2.fastq.gz'],
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 2     // max_retries
                input[5] = 1     // wait_retry
                input[6] = 60    // timeout
                input[7] = true  // resume
                input[8] = true  // soft_fail
                """
            }
        }

        then {
            assert process.success

            // Status should report failure
            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            def log_text = path(process.out.download_log[0][1]).text

            // Both attempts should succeed at downloading
            assert log_text.contains("=== Attempt 1/2 ===")
            assert log_text.contains("=== Attempt 2/2 ===")
            assert log_text.contains("Download succeeded, running fastp...")

            // But fastp should fail on each attempt
            assert log_text.contains("fastp failed on attempt 1")
            assert log_text.contains("fastp failed on attempt 2")
            assert log_text.contains("All 2 attempts failed")
            assert log_text.contains("Soft fail mode: creating empty output files")

            // Sleep between attempts
            assert log_text.contains("Sleeping 1s before next attempt...")

            // Download should never have failed
            assert !log_text.contains("Download failed")
        }
    }

    // =========================================================================
    // test_pe_mismatch: fastp retry — 3 retries, soft fail
    // =========================================================================

    test("test_pe_mismatch: retries on fastp failure 3 times then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_pe_mismatch', single_end: false],
                    ['ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_1.fastq.gz',
                     'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/007/ERR10889407/ERR10889407_2.fastq.gz'],
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 3     // max_retries
                input[5] = 1     // wait_retry
                input[6] = 60    // timeout
                input[7] = true  // resume
                input[8] = true  // soft_fail
                """
            }
        }

        then {
            assert process.success

            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            def log_text = path(process.out.download_log[0][1]).text

            // All 3 attempts with fastp failures
            assert log_text.contains("=== Attempt 1/3 ===")
            assert log_text.contains("=== Attempt 2/3 ===")
            assert log_text.contains("=== Attempt 3/3 ===")
            assert log_text.contains("fastp failed on attempt 1")
            assert log_text.contains("fastp failed on attempt 2")
            assert log_text.contains("fastp failed on attempt 3")
            assert log_text.contains("All 3 attempts failed")
            assert log_text.contains("Soft fail mode: creating empty output files")

            // Downloads always succeeded
            assert !log_text.contains("Download failed")
            assert !log_text.contains("Attempt 4/")
        }
    }

    // =========================================================================
    // test_pe_mismatch: hard failure — soft_fail disabled
    // =========================================================================

    test("test_pe_mismatch: fails when soft_fail is disabled") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_pe_mismatch', single_end: false],
                    ['ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_1.fastq.gz',
                     'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/007/ERR10889407/ERR10889407_2.fastq.gz'],
                    []
                ])
                input[1] = false  // discard_trimmed_pass
                input[2] = false  // save_trimmed_fail
                input[3] = false  // save_merged
                input[4] = 1     // max_retries
                input[5] = 1     // wait_retry
                input[6] = 60    // timeout
                input[7] = true  // resume
                input[8] = false // soft_fail disabled
                """
            }
        }

        then {
            assert process.failed
        }
    }
}
