nextflow_process {

    name "Test Process FTP_FETCH_BBMAP_REFORMAT_STANDARDISE"
    script "modules/local/ftp_fetch_bbmap_reformat_standardise/main.nf"
    process "FTP_FETCH_BBMAP_REFORMAT_STANDARDISE"
    config "tests/modules/local/ftp_fetch_bbmap_reformat_standardise/nextflow.config"

    // =========================================================================
    // test_se: Single-end — successful download and reformat
    // =========================================================================

    test("test_se: downloads and reformats single-end reads successfully") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se', single_end: true, interleaved: false],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_1.fastq.gz'
                ])
                input[1] = 'fastq.gz' // out_fmt
                input[2] = 3     // max_retries
                input[3] = 10    // wait_retry
                input[4] = 60    // timeout
                input[5] = true  // resume
                input[6] = false // soft_fail
                """
            }
        }

        then {
            assert process.success

            // Verify all expected outputs are emitted
            assert process.out.reformated.size() == 1
            assert process.out.log.size() == 1
            assert process.out.download_log.size() == 1
            assert process.out.status.size() == 1

            // Status should report success
            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "true"

            // Download log should show a clean first-attempt success
            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/3 ===")
            assert log_text.contains("Download succeeded, running reformat.sh...")
            assert log_text.contains("reformat.sh succeeded on attempt 1")
            // No failures should be logged
            assert !log_text.contains("Download failed")
            assert !log_text.contains("reformat.sh failed")
            assert !log_text.contains("Attempt 2/3")
        }
    }

    // =========================================================================
    // test_se_wrong_path: wget retry — 2 retries, soft fail
    // =========================================================================

    test("test_se_wrong_path: retries wget download 2 times then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se_wrong_path', single_end: true, interleaved: false],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412__1.fastq.gz'
                ])
                input[1] = 'fastq.gz' // out_fmt
                input[2] = 2     // max_retries
                input[3] = 1     // wait_retry (short for testing)
                input[4] = 5     // timeout (short for testing)
                input[5] = false // resume
                input[6] = true  // soft_fail
                """
            }
        }

        then {
            assert process.success

            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/2 ===")
            assert log_text.contains("=== Attempt 2/2 ===")
            assert log_text.contains("Download failed")
            assert log_text.contains("All 2 attempts failed")
            assert log_text.contains("Soft fail mode: creating empty output files")

            assert log_text.contains("Sleeping 1s before next attempt...")

            assert !log_text.contains("running reformat.sh")
        }
    }

    // =========================================================================
    // test_se_wrong_path: wget retry — 3 retries, soft fail
    // =========================================================================

    test("test_se_wrong_path: retries wget download 3 times then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se_wrong_path', single_end: true, interleaved: false],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412__1.fastq.gz'
                ])
                input[1] = 'fastq.gz' // out_fmt
                input[2] = 3     // max_retries
                input[3] = 1     // wait_retry
                input[4] = 5     // timeout
                input[5] = false // resume
                input[6] = true  // soft_fail
                """
            }
        }

        then {
            assert process.success

            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/3 ===")
            assert log_text.contains("=== Attempt 2/3 ===")
            assert log_text.contains("=== Attempt 3/3 ===")
            assert log_text.contains("Download failed")
            assert log_text.contains("All 3 attempts failed")
            assert log_text.contains("Soft fail mode: creating empty output files")

            assert !log_text.contains("Attempt 4/")
        }
    }

    // =========================================================================
    // test_se_wrong_path: hard failure — soft_fail disabled
    // =========================================================================

    test("test_se_wrong_path: fails when soft_fail is disabled") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_se_wrong_path', single_end: true, interleaved: false],
                    'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412__1.fastq.gz'
                ])
                input[1] = 'fastq.gz' // out_fmt
                input[2] = 1     // max_retries
                input[3] = 1     // wait_retry
                input[4] = 5     // timeout
                input[5] = false // resume
                input[6] = false // soft_fail disabled
                """
            }
        }

        then {
            assert process.failed
        }
    }

    // =========================================================================
    // test_pe: Paired-end — successful download and reformat
    // =========================================================================

    test("test_pe: downloads and reformats paired-end reads successfully") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_pe', single_end: false, interleaved: false],
                    ['ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_1.fastq.gz',
                     'ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR108/012/ERR10889412/ERR10889412_2.fastq.gz']
                ])
                input[1] = 'fastq.gz' // out_fmt
                input[2] = 3     // max_retries
                input[3] = 10    // wait_retry
                input[4] = 60    // timeout
                input[5] = true  // resume
                input[6] = false // soft_fail
                """
            }
        }

        then {
            assert process.success

            assert process.out.reformated.size() == 1
            assert process.out.log.size() == 1
            assert process.out.download_log.size() == 1
            assert process.out.status.size() == 1

            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "true"

            def log_text = path(process.out.download_log[0][1]).text
            assert log_text.contains("=== Attempt 1/3 ===")
            assert log_text.contains("Downloading")
            assert log_text.contains("ERR10889412_1.fastq.gz")
            assert log_text.contains("ERR10889412_2.fastq.gz")
            assert log_text.contains("Download succeeded, running reformat.sh...")
            assert log_text.contains("reformat.sh succeeded on attempt 1")
            assert !log_text.contains("Download failed")
            assert !log_text.contains("reformat.sh failed")
        }
    }

    // =========================================================================
    // test_pe_mismatch: tool retry — 2 retries, soft fail
    // =========================================================================

    test("test_pe_mismatch: retries on reformat.sh failure 2 times then soft-fails") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_pe_mismatch', single_end: false, interleaved: false],
                    ['https://raw.githubusercontent.com/nf-core/test-datasets/modules/data/genomics/sarscov2/illumina/fastq/test_1.fastq.gz',
                     'https://raw.githubusercontent.com/nf-core/test-datasets/modules/data/genomics/sarscov2/genome/genome.fasta.fai']
                ])
                input[1] = 'fastq.gz' // out_fmt
                input[2] = 2     // max_retries
                input[3] = 1     // wait_retry
                input[4] = 60    // timeout
                input[5] = false // resume
                input[6] = true  // soft_fail
                """
            }
        }

        then {
            assert process.success

            def status_text = path(process.out.status[0][1]).text.trim()
            assert status_text == "false"

            def log_text = path(process.out.download_log[0][1]).text

            assert log_text.contains("=== Attempt 1/2 ===")
            assert log_text.contains("=== Attempt 2/2 ===")
            assert log_text.contains("Download succeeded, running reformat.sh...")

            assert log_text.contains("reformat.sh failed on attempt 1")
            assert log_text.contains("reformat.sh failed on attempt 2")
            assert log_text.contains("All 2 attempts failed")
            assert log_text.contains("Soft fail mode: creating empty output files")

            assert log_text.contains("Sleeping 1s before next attempt...")

            assert !log_text.contains("Download failed")
        }
    }

    // =========================================================================
    // test_pe_mismatch: hard failure — soft_fail disabled
    // =========================================================================

    test("test_pe_mismatch: fails when soft_fail is disabled") {

        when {
            process {
                """
                input[0] = Channel.of([
                    [id: 'test_pe_mismatch', single_end: false, interleaved: false],
                    ['https://raw.githubusercontent.com/nf-core/test-datasets/modules/data/genomics/sarscov2/illumina/fastq/test_1.fastq.gz',
                     'https://raw.githubusercontent.com/nf-core/test-datasets/modules/data/genomics/sarscov2/genome/genome.fasta.fai']
                ])
                input[1] = 'fastq.gz' // out_fmt
                input[2] = 1     // max_retries
                input[3] = 1     // wait_retry
                input[4] = 60    // timeout
                input[5] = false // resume
                input[6] = false // soft_fail disabled
                """
            }
        }

        then {
            assert process.failed
        }
    }
}
